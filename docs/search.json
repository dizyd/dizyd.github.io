[
  {
    "objectID": "pages/about.html",
    "href": "pages/about.html",
    "title": "David Izydorczyk",
    "section": "",
    "text": "This website and the blogs on it are about:\n\nthings I learned, to make it simpler for me to do the same thing again next time,\nthings I learned, to make it simpler for other people to learn the same thing quicker,\nthings I wanted to (start) learn(ing)\nthings I always forget where to look them up\n\nYou can contact me via izydorczyk@uni-mannheim.de."
  },
  {
    "objectID": "pages/cv.html",
    "href": "pages/cv.html",
    "title": "CV",
    "section": "",
    "text": "Doctoral (Ph.D.) Candidate in Psychology , University of Mannheim, since 10/2016,\nDoctoral program at the DFG Research Training Group “Statistical Modeling in Psychology” (SMiP) (supervisors: Arndt Bröder, Benjamin Hilbig, Jeff Rouder)\nM.Sc. Psychology, University of Cologne, 10/2016-09/2018, research-oriented psychology with specializations in cognitive psychology, media psychology, and neuroscience. Thesis: Simulating the ecology: Using the BIAS model to simulate and explain contradicting evidence of the out-group homogeneity effect, the intergroup bias, and the density hypothesis (advisors: Christian Unkelbach, Jan Peters)\nB.Sc. Psychology, University of Koblenz-Landau, 10/2012-09/2016. Thesis: Structuring the uncanny valley: Investigating the effect of the personal need for structure on the uncanny valley phenomenon by using mixed-effects modelling with partially crossed random effects (advisors: Markus Appel, Tanja Lischetzke)"
  },
  {
    "objectID": "pages/cv.html#teaching-experience",
    "href": "pages/cv.html#teaching-experience",
    "title": "CV",
    "section": " Teaching Experience",
    "text": "Teaching Experience\nExperimental Internship, University of Mannheim, Department of Experimental Psychology (level: Bachelor; language: German)\nWorkshop Advanced R, University of Mannheim , RTG Statistical Modeling in Psychology (level: P.hD.; language: English)\nWorkshop Modern R, University of Mannheim , RTG Statistical Modeling in Psychology (level: P.hD.; language: English)\nTutorial Multivariate Statistics, University of Cologne , Department for Research Methods and Experimental Psychology (level: M.Sc.; language: German)\nTutorial Multivariate Statistics, University of Cologne , Department for Research Methods and Experimental Psychology (level: M.Sc.; language: German)\nTutorial Data Collection and Analysis, University of Cologne , Department for Research Methods and Experimental Psychology (level: M.Sc.; language: German)\nTutorial Empirical Internship, University of Koblenz-Landau, Department for Methods and Evaluation (level: B.Sc.; language: German)\nWorkshop Introduction to R, University of Koblenz-Landau, Department for Methods and Evaluation (level: P.hD.; language: English)\nTutorial Test Theory with R, University of Koblenz-Landau, Department for Methods and Evaluation (level: B.Sc.; language: German)"
  },
  {
    "objectID": "pages/cv.html#programming-and-statistics",
    "href": "pages/cv.html#programming-and-statistics",
    "title": "CV",
    "section": " Programming and statistics",
    "text": "Programming and statistics\nLanguages: Mastery of R. Regular practice writing JAGS, Stan for Bayesian modeling, as well as HTML/CSS and JavaScript to program experiments. I also did some courses in and analysis with Python. Exposure to C++.\nComputing tools and technologies: tidy data and the R tidyverse, git and GitHub, knitr/rmarkdown, Shiny.\nStatistics: Regression: generalized linear models, hierarchical and mixed effects models, and Bayesian versions of these models. Structural equation modeling and factor analysis. Neural networks: familiarity with how some deep network architectures work.\nExperimental software: nowadays mostly lab.JS and Soscisurvey. Some experience with OpenSesame and Inquisit."
  },
  {
    "objectID": "pages/cv.html#university-service",
    "href": "pages/cv.html#university-service",
    "title": "CV",
    "section": " University Service",
    "text": "University Service\nElected Ph.D. students Spokesperson, since 2020, Research Training Group Statistical Modeling in Psychology, University of Mannheim"
  },
  {
    "objectID": "pages/cv.html#reviewing",
    "href": "pages/cv.html#reviewing",
    "title": "CV",
    "section": " Reviewing",
    "text": "Reviewing\nAd-hoc reviewer: Computers in Human Behaviour, Judgment and Decision Making"
  },
  {
    "objectID": "pages/cv.html#professional-memberships",
    "href": "pages/cv.html#professional-memberships",
    "title": "CV",
    "section": " Professional Memberships",
    "text": "Professional Memberships\nGerman Psychological Society (DGPs) Sections Methods and Evaluation and General Psychology"
  },
  {
    "objectID": "pages/cv.html#workshops-and-summerschools",
    "href": "pages/cv.html#workshops-and-summerschools",
    "title": "CV",
    "section": " Workshops and Summerschools",
    "text": "Workshops and Summerschools\n\n2019\nIntroduction to Stan: A Probabilistic Programming Language for Bayesian Inference, Workshop by Paul Bürkner, 2019, at University of Mannheim, Germany\nAn Introduction to Machine Learning, Workshop by Andreas Brandmeaier, 2019, at University of Mannheim, Germany\nNHST reloaded: Recent developments, Workshop by Rolf Ulrich and Jeff Miller, 2019, at University of Tübingen, Germany\nModel-based Neuroscience, Summer School, 2019, at University of Amsterdam, Netherlands\nA Modern Axiomatic Perspective: Theory, Statistical Methodology, and Experimental Design, Workshop by Clintin Davis-Stober, 2019, at University of Mannheim, Germany\nPython basics, Workshop by Stefan Radev, 2019, at University of Heidelberg, Germany\nHypothesis Evaluation Using the Bayes Factor, Workshop by Herbert Hoijtink, 2019, at University of Mannheim, Germany\nIntroduction to Bayesian Inference: Core Principles and Application in Stan, Workshop by Daniel Heck, 2019, at University of Mannheim, Germany\nNumerical Methods for Quantitative Psychologists, Workshop by Francis Tuerlinckx, 2019, at University of Tübingen, Germany\nAcademic Writing and Publishing, Workshop by Benjamin Hilbig, 2019, at University of Koblenz-Landau, Germany\n\n\n2018\nAn Introduction to modern R, Statistical Modeling, and Mixed Models, Workshopy by Henrik Singmann, 2018, at University of Freiburg, Germany\nAdvanced Topics in R, Workshopy by Daniel Heck, 2018, at University of Mannheim, Germany\nAnalysis of Response Time, Workshopy by Trisha van Zandt, at University of Mannheim, Germany\nRules of Good Scientific Practice, Workshop by Arndt Bröder, 2018, at University of Mannheim, Germany\n\n\n2014\nStructural equation modelling in R with lavaan, Workshop by Dorota Reis & Tanja Lischetzke, 2014, University of Koblenz-Landau, Germany"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "David Izydorczyk",
    "section": "",
    "text": "This website and the blogs on it are about:\n\nthings I learned, to make it simpler for me to do the same thing again next time,\nthings I learned, to make it simpler for other people to learn the same thing quicker,\nthings I wanted to (start) learn(ing)\nthings I always forget where to look them up\n\nYou can contact me via izydorczyk@uni-mannheim.de."
  },
  {
    "objectID": "pages/publications.html",
    "href": "pages/publications.html",
    "title": "Publications",
    "section": "",
    "text": "Ruggeri K., …, Izydorczyk, D., …, & Garcia-Garzon, E. (preprint only). The globalizability of temporal discounting. (preprint available PDF)\nFrenken, M., Hemmerich, W., Izydorczyk, D., Scharf, S., & Imhoff, R. (2021). Cognitive processes behind the shooter bias: Dissecting response bias, motor preparation and information accumulation. Journal of Experimental Social Psychology. (https://doi.org/10.1016/j.jesp.2021.104230, preprint available PDF)\nIzydorczyk, D., & Bröder, A. (2021). Exemplar-based judgment or direct recall: On a problematic procedure for estimating parameters in exemplar models of quantitative judgment. Psychonomic Bulletin & Review. (https://doi.org/10.3758/s13423-020-01861-1)(PDF)\n\n\n\nAppel, M., Izydorczyk, D., Weber, S., Mara, M., & Lischetzke, T. (2020). The uncanny of mind in a machine: Humanoid robots as tools, agents, and experiencers. Computers in Human Behavior, 102, 274-286.(https://doi.org/10.1016/j.chb.2019.07.031) (PDF)\n\n\n\nMascarenhas, M. F., Dübbers, F.,Hoszowska, M., Köseoğlu, A., Karakasheva, R. B. Topal, A.& Izydorczyk, D.,Lemoine, J.E.(2018). The Power of Choice: A Study Protocol on How Identity Leadership Fosters Commitment Toward the Organization. Frontiers in Psychology. (https://doi.org/10.3389/fpsyg.2018.01677)\n\n\n\nLischetzke, T., Izydorczyk, D., Hüller, C., & Appel, M. (2017). The topography of the uncanny valley and individuals’ need for structure: A nonlinear mixed effects analysis. Journal of Research in Personality.68, 96-113. (https://doi.org/10.1016/j.jrp.2017.02.001)"
  },
  {
    "objectID": "pages/publications.html#presentations",
    "href": "pages/publications.html#presentations",
    "title": "Publications",
    "section": " Presentations",
    "text": "Presentations\n\n\n Conference talks\nIzydorzcyk, D., Jung, J. & Bröder, A. (2022). What is more democratic, a stone or a feather? Predicting nonsensical judgments using high-dimensional vector representations obtained from a semantic space model. Talk presented at the 63rd Conference of Experimental Psychologists (TeaP). Cologne, Germany.\nIzydorzcyk, D. & Bröder, A. (2021). Measuring Eule‐ and Exemplar‐based Processes of numerical Judgments in a hierarchical Bayesian framework. Talk presented at the 15th Conference of the Section Methods & Evaluation (FGME 2021). Mannheim, Germany.\nIzydorzcyk, D. & Bröder, A. (2021). Judgment or Recall: On the Problematic Procedure for Estimating Parameters of Exemplar Models in Experiments of Quantitative Judgment. Talk presented at the annual joint meeting of the Society for Mathematical Psychology and the International Conference on Cognitive Modeling (MathPsych/ICCM 2021). Virtual Conference.\nIzydorzcyk, D. & Bröder, A. (2021). Judgment or Recall: On the Problematic Procedure for Estimating Parameters of Exemplar Models in Experiments of Quantitative Judgment. Talk presented at the 63rd Conference of Experimental Psychologists (TeaP). Würzburg, Germany.\n\n\n\n Coauthored talks (i.e., I didn’t talk, but probably did stats and made figures)\nBaumert, A., Schopke, A. & Izydorzcyk, D. (2021). Reactions to Others‘ Norm Violations in Everyday Life – Scrutinizing Reactivity to Intensive Assessments. Talk presented at the Society for Ambulatory Assessment Conference 2021 (SAA). Zürich, Switzerland.\nMascarenhas, M. F., Dbbers, F., Hoszowska, M., Kseolu, A., Karakasheva, R., Topal,A. B.,Izydorzcyk, D. & Lemoine, J. E. (2018). Leading us towards more commitment. Talk presented at the 2018 Junior Researcher Programme Conference, August 13-14, Cambridge, United-Kingdom.\n\n\n\n Posters\nIzydorzcyk, D. & Unkelbach, C. (2019). Simulating the ecology: Using the BIASmodel to simulate and explain contradicting evidence of the out-group homogeneity ef-fect, the intergroup bias, and the density hypothesis. Poster presented at the 27th Subjective Probability, Utility, and Decision Making Conference (SPUDM27). Amsterdam, Netherlands.\nIzydorzcyk, D. & Unkelbach, C. (2019). Simulating the ecology: Using the BIASmodel to simulate and explain contradicting evidence of the out-group homogeneityeffect, the intergroup bias, and the density hypothesis. Poster presented at the 17th Conference of the Social Psychology Section, September 16-17, Cologne, Germany.\nIzydorzcyk, D. (2019). Measuring Rule- and Exemplar-based Processes in Numerical Judgments. Poster presented at the 34th IOPS Summer Conference, June 14-16, Utrecht, Netherlands.\nTopal, A. B., Karakasheva, R., Mascarenhas, M. F., Dbbers, F., Hoszowska, M., Kse-olu, A., Izydorzcyk, D., Lemoine, J. E. (2018). The power of choice: How identity leadership fosters commitment towards the organization. Poster presented at the 2018 jMeeting, February 2, Madrid, Spain"
  },
  {
    "objectID": "pages/rserver_documentation.html",
    "href": "pages/rserver_documentation.html",
    "title": "R Server Documentation",
    "section": "",
    "text": "you can add new users with by typing the command sudo adduser newuser in the Terminal (you have to be logged in with an admin account) where you should replace newuser with the name of the user you want to create\nyou will be prompted to give some information for the user like an initial password etc."
  },
  {
    "objectID": "pages/rserver_documentation.html#rserver-commands",
    "href": "pages/rserver_documentation.html#rserver-commands",
    "title": "R Server Documentation",
    "section": "RServer commands",
    "text": "RServer commands\nhere are some useful RServer commands\n\nsudo rstudio-server stop\nsudo rstudio-server start\nsudo rstudio-server restart\nsudo rstudio-server status\nsudo rstudio-server active-sessions"
  },
  {
    "objectID": "pages/rserver_documentation.html#add-user-to-group",
    "href": "pages/rserver_documentation.html#add-user-to-group",
    "title": "R Server Documentation",
    "section": "Add User to group",
    "text": "Add User to group\n\nThis commands adds a user to a group sudo usermod -a -G <groupname> <username>"
  },
  {
    "objectID": "pages/rserver_documentation.html#check-r-version",
    "href": "pages/rserver_documentation.html#check-r-version",
    "title": "R Server Documentation",
    "section": "Check R Version",
    "text": "Check R Version\n\nyou can check the R version with the command R --version"
  },
  {
    "objectID": "pages/rserver_documentation.html#update-r-version-of-rserver",
    "href": "pages/rserver_documentation.html#update-r-version-of-rserver",
    "title": "R Server Documentation",
    "section": "Update R Version of RServer",
    "text": "Update R Version of RServer\n\nto update the RVersion of the RServer you just have to update R on the computer the Server runs on. To do this, check the many up to date explanations on the internet (Google: “update R ubuntu 20.04”)"
  },
  {
    "objectID": "pages/rserver_documentation.html#show-memory-and-cpu-workload",
    "href": "pages/rserver_documentation.html#show-memory-and-cpu-workload",
    "title": "R Server Documentation",
    "section": "Show memory and CPU workload",
    "text": "Show memory and CPU workload\n\nin the Terminal type htop which gives you detailed information about memory and CPU usage"
  },
  {
    "objectID": "pages/rserver_documentation.html#change-your-own-password",
    "href": "pages/rserver_documentation.html#change-your-own-password",
    "title": "R Server Documentation",
    "section": "Change your own password",
    "text": "Change your own password\n\nin the Terminal type passwd\ninsert your password"
  },
  {
    "objectID": "pages/rserver_documentation.html#changing-the-password-of-another-user",
    "href": "pages/rserver_documentation.html#changing-the-password-of-another-user",
    "title": "R Server Documentation",
    "section": "Changing the password of another user",
    "text": "Changing the password of another user\n\nsign in with an admin account\nin Terminal type sudo passwd user where you should replace user with the name of the user you want to change the password of\nconfirm comand with admin password\ntype in new password"
  },
  {
    "objectID": "pages/rserver_documentation.html#check-ubuntu-version",
    "href": "pages/rserver_documentation.html#check-ubuntu-version",
    "title": "R Server Documentation",
    "section": "Check Ubuntu Version",
    "text": "Check Ubuntu Version\n\nyou can check the currently installed Ubuntu Version with by typing lsb_release -a in the terminal"
  },
  {
    "objectID": "pages/rserver_documentation.html#restartreboot-computer-via-the-terminal-in-rstudio",
    "href": "pages/rserver_documentation.html#restartreboot-computer-via-the-terminal-in-rstudio",
    "title": "R Server Documentation",
    "section": "Restart/reboot computer via the terminal in RStudio",
    "text": "Restart/reboot computer via the terminal in RStudio\n\nyou can also restart/reboot the computer running the RServer via the terminal pane in RStudio with the command sudo reboot"
  },
  {
    "objectID": "pages/rserver_documentation.html#look-up-ip-adress",
    "href": "pages/rserver_documentation.html#look-up-ip-adress",
    "title": "R Server Documentation",
    "section": "look up IP adress",
    "text": "look up IP adress\n\nifconfig"
  },
  {
    "objectID": "pages/rserver_documentation.html#open-and-close-documents-with-vim",
    "href": "pages/rserver_documentation.html#open-and-close-documents-with-vim",
    "title": "R Server Documentation",
    "section": "Open and Close documents with vim",
    "text": "Open and Close documents with vim\n\nSometimes you have to open & edit documents in a text editor via the terminal, for instance vim\nyou can open documents in the terminal with vim by typing vim document\nTo close a document :q and hit Enter"
  },
  {
    "objectID": "pages/shiny.html",
    "href": "pages/shiny.html",
    "title": "Shiny",
    "section": "",
    "text": "I have developed a number of R shiny apps which I want to link here, that are available for exploration. Be warned that the apps have limited (i.e. no) documentation or guidance. They were designed to be intuitive, but maybe only in the eyes of the creator. The software provided on this website may be used for non-commercial purposes free of charge. Although considerable effort was put into developing and testing the software, there is no warranty whatsoever."
  },
  {
    "objectID": "pages/shiny.html#curtailed-rrt-made-easy",
    "href": "pages/shiny.html#curtailed-rrt-made-easy",
    "title": "Shiny",
    "section": "Curtailed RRT made easy",
    "text": "Curtailed RRT made easy\nThis is a shiny-app is part of a published paper for sequential hypothesis testing whithin a Curtailed Sampling Plan using Randomized Response Techniques by Reiber, F., Schnuerch, M. & Ulrich, R. (in press). Improving the efficiency of surveys with randomized response models: A sequential approach based on curtailed sampling. Psychological Methods."
  },
  {
    "objectID": "pages/teaching.html#workshops-phd-level",
    "href": "pages/teaching.html#workshops-phd-level",
    "title": "Teaching",
    "section": "Workshops (PhD level)",
    "text": "Workshops (PhD level)\nIntroduction to lab.js: This workshop teaches the basics of of `lab.js, a free, open, online study builder for the behavioral and cognitive sciences. Participants learn to create their own experiments using the builder GUI, HTML, CSS and JavaScript.\nWorkshop Modern R: This workshop teaches the basics of R Markdown and how to write APA conform manuscripts using R Markdown and the papaja-package. In addition, it will give an introduction into building interactive web applications in R with shiny.\nWorkshop Advanced R: This workshop shows how to benchmark and profile functions in R to identify potential bottlenecks. The workshops then also shows how to solve those bottlenecks and speed up your R code through vectorized R code, Rcpp, or parallelization."
  },
  {
    "objectID": "pages/teaching.html#seminars-bachelor",
    "href": "pages/teaching.html#seminars-bachelor",
    "title": "Teaching",
    "section": "Seminars (Bachelor)",
    "text": "Seminars (Bachelor)\nGeneral Psychology II: Topics: Cognitive Illusions.\nProject Seminar Experimental Psychology: In this seminar, students plan, conduct, and present their own research project in small groups. Projects supervised so far:\n\nWie beeinflusst die Berichterstattung über Corona das Entscheidungsverhalten?\nFraming Effekt in Zeiten einer Pandemie: Krankheit oder Risiko?"
  },
  {
    "objectID": "pages/blog.html",
    "href": "pages/blog.html",
    "title": "Blog",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html",
    "href": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html",
    "title": "Predicting the WM22 Part 1",
    "section": "",
    "text": "With this series of blog posts, I wanted to learn more about Python, plotting maps with ggplot, modeling with STAN, football (?) and just practice writing. The aim is to predict the games of the 2022 football world championship using data from the qualifying games of all countries and informations about the individual players of each team. I scraped the data from open websites using Python. The scripts can be found on the corresponding Github page of this project. In this first blog post of the series, I want to explore the data set results_quali_matches.csv which contains the data of all qualifying games. I never used spatial data or plotted spatial data, so since I have data from all over the world, I want to try out plotting maps with ggplot. The main point of this blog post, however, is to get a feel for the data we have, which will be useful for our modeling attempts later."
  },
  {
    "objectID": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#making-world-maps-using-the-ggplot2",
    "href": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#making-world-maps-using-the-ggplot2",
    "title": "Predicting the WM22 Part 1",
    "section": "Making world maps using the ggplot2",
    "text": "Making world maps using the ggplot2\nNow I want to make a world map and then color each country by the number of goals scored/received. For this I will use the map package, which provides a data.frame that contains outlines of several continents.\n\n\nCode\nworld <- map_data(\"world\")\n\nhead(world)\n\n\n       long      lat group order region subregion\n1 -69.89912 12.45200     1     1  Aruba      <NA>\n2 -69.89571 12.42300     1     2  Aruba      <NA>\n3 -69.94219 12.43853     1     3  Aruba      <NA>\n4 -70.00415 12.50049     1     4  Aruba      <NA>\n5 -70.06612 12.54697     1     5  Aruba      <NA>\n6 -70.05088 12.59707     1     6  Aruba      <NA>\n\n\nThis world data.frame has the following variables: long for longitude, lat for latitude, group tells which adjacent points to connect, order refers to the sequence by which the points should be connected, and region and subregion annotate the area surrounded by a set of points. We can use this information to plot the world using ggplot:\n\n\nCode\nggplot(data = world, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\")  +\n  coord_fixed(1.3) + theme_map() # looks better\n\n\n\n\n\nBeautiful, isn’t it ? In order to color each country by the number of goals scored or received, we have to join the world and the country_stats data.frames together. However, before we can do this, we first have to make some processing steps in both data.frames. First, I need to translate the country names in the country_stats data.frames from German to English, since the region column in world contains the Names in English. Second, in the country_stats data.frame I have some “countries” which are rather sub-regions in world, for instance, Wales or Scotland. Thus, I need to create a new column in world which contains the same “countries” as in country_stats.\nTo translate the names, I use the countrycode package.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = countrycode(country, origin      = 'country.name.de',\n                                                             destination = 'country.name.en'))\ncountry_stats %>% head()\n\n\n# A tibble: 6 × 4\n  country    scored received country_en\n  <chr>       <dbl>    <dbl> <chr>     \n1 Japan          58        6 Japan     \n2 Kanada         50        8 Canada    \n3 Iran           49        8 Iran      \n4 Australien     43       11 Australia \n5 Brasilien      40        5 Brazil    \n6 China          39       22 China     \n\n\nThis worked quite well, except for the following warning: Some values were not matched unambiguously: Br. Jungferninseln, Djibouti, Dom. Republik, England, Kapverdische Inseln, Schottland, Sénégal, VA Emirate, Wales, Zentralafr. Republik. So I still have to put in some work by myself. I also added additional country name changes, based on checks a few code chunks further down.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = case_when(\n                      country == \"Djibouti\" ~ \"Djibouti\", # not sure why this didnt work before\n                      country == \"Br. Jungferninseln\" ~ \"Virgin Islands\",\n                      country == \"Dom. Republik\" ~ \"Dominican Republic\",\n                      country == \"England\" ~ \"Great Britain\",\n                      country == \"Kapverdische Inseln\" ~ \"Cape Verde\",\n                      country == \"Schottland\" ~ \"Scotland\",\n                      country == \"Sénégal\" ~ \"Senegal\",\n                      country == \"Wales\" ~ \"Wales\",\n                      country == \"Zentralafr. Republik\" ~ \"Central African Republic\",\n                      country == \"Bosnien-Herzegowina\" ~ \"Bosnia and Herzegovina\",\n                      country == \"Elfenbeinküste\" ~ \"Ivory Coast\",\n                      country == \"Tschechien\" ~ \"Czech Republic\",\n                      country == \"Curaçao\" ~ \"Curacao\",\n                      country == \"Kongo\" ~ \"Republic of Congo\",\n                      country == \"USA\" ~ \"USA\",\n                      country == \"DR Kongo\" ~ \"Democratic Republic of the Congo\",\n                      country == \"St. Kitts & Nevis\" ~ \"Nevis\",\n                      country == \"Antigua & Barbuda\" ~ \"Antigua\",\n                      country == \"Turks & Caicos\" ~ \"Turks and Caicos Islands\",\n                      country == \"Trinidad & Tobago\" ~ \"Trinidad\",\n                      country == \"St. Vincent/Grenadines\" ~ \"Saint Vincent\",\n                      country == \"VA Emirate\" ~ \"United Arab Emirates\",\n                      country == \"Hong Kong SAR China\" ~ \"Hongkong\",\n                      country == \"Palästina\" ~ \"Palestine\",\n                      country == \"Myanmar\" ~ \"Myanmar\",\n                      country == \"Nordirland\" ~ \"Northern Ireland\",\n                      TRUE ~ country_en\n                    )) \n \n\n\n# check if we have everything:\n# country_stats %>% filter(is.na(country_en))\ncountry_stats %>% head()\n\n\n# A tibble: 6 × 4\n  country    scored received country_en\n  <chr>       <dbl>    <dbl> <chr>     \n1 Japan          58        6 Japan     \n2 Kanada         50        8 Canada    \n3 Iran           49        8 Iran      \n4 Australien     43       11 Australia \n5 Brasilien      40        5 Brazil    \n6 China          39       22 China     \n\n\nNext I make a new variable in the worlds data.frame, which I will then use to join both data.frames together.\n\n\nCode\nworld <- world %>%\n            mutate(country_en = case_when(subregion == \"Wales\" ~ \"Wales\",\n                                          subregion == \"Northern Ireland\" ~ \"Northern Ireland\",\n                                          subregion == \"Scotland\" ~ \"Scotland\",\n                                          subregion == \"Great Britain\" ~ \"Great Britain\",\n                                          subregion == \"Grand Caicos Island\" ~ \"Turks and Caicos Islands\",\n                                          subregion == \"British\" ~ \"Virgin Islands\",\n                                          subregion == \"Hong Kong\" ~ \"Hong Kong\",\n                                          TRUE ~ region)) %>% \n            filter(region != \"USA\" | region == \"USA\" & (is.na(subregion) | subregion == \"Alaska\"),\n                   region != \"United Arab Emirates\" | region == \"United Arab Emirates\" & is.na(subregion),\n                   region != \"Myanmar\" | region == \"Myanmar\" & is.na(subregion),\n                   region != \"Ireland\" | region == \"Ireland\" & is.na(subregion))\n  \n# We need to add Gibraltar through a different dataset\n# \"worldHires\" is a more detailed version of \"world\"\ntemp <- map_data('worldHires')  %>% filter(subregion == \"Gibralter\") %>% mutate(country_en = \"Gibraltar\")\n  \n\nworld <- bind_rows(world,temp) %>% as_tibble() \n\n\nNow we can join both data.frames using left_join. Lets also clean the resulting data.frame a little bit.\n\n\nCode\ncountry_stats <- left_join(country_stats,world,by=\"country_en\") %>% \n                      select(region = country_en, scored, received, long, lat, group, order )\n\n# checks:\n# check if any countries do not have infos from world\n# country_stats %>% filter(is.na(long)) %>% pull(region) %>% unique()\n\n\nGreat, after some back and forth changes, I think I now have the position of every country in our data set. Lets check this, by just plotting all countries or regions where we have some data from.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\") +\n  coord_fixed(1.3) + theme_map()\n\n\n\n\n\nSo we this really is a “World” championship."
  },
  {
    "objectID": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#color-regions-by-goals-scored-and-recevied",
    "href": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#color-regions-by-goals-scored-and-recevied",
    "title": "Predicting the WM22 Part 1",
    "section": "Color regions by goals scored and recevied",
    "text": "Color regions by goals scored and recevied\nHere I color each country or region by the number of goals they scored and received in their qualifying matches. From the plots you can identify some countries which apparently did well in their group, since the score many goals, but received only few. For instance, Canada, Japan, German, or Brasil. There also seem to be fewer goals in African and south-east Asian countries.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Scored\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=received), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Received\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\n\nCode\n# p1 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Scored\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# p2 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=received), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Received\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# \n# p1 / p2\n# \n# \n# ggsave(\"goals_WM22_qualifying.svg\",width=30,height=30,unit=\"cm\")"
  },
  {
    "objectID": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#goals-scored-and-received-per-country",
    "href": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#goals-scored-and-received-per-country",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per Country",
    "text": "Goals Scored and Received per Country\n\n\nCode\ntemp <- country_stats %>% select(region,scored,received) %>% distinct()\n\n\nI also want to get a general idea of the distribution and relationship of the scored and received goals. There is only a small negative correlation between the number of goals scored and the number of goals received (r = -0.16), mostly driven by Japan.\n\n\nCode\np_scatter <- ggplot(temp,aes(x = scored, y = received)) +\n              geom_point(shape = 21, fill = \"lightgrey\",size = 2) +\n              geom_smooth(method = \"lm\") +\n              geom_label_repel(aes(label = region),\n                               box.padding   = 0.35, \n                               point.padding = 0.5,\n                               segment.color = 'grey50')\n\np_scatter\n\n\n\n\n\nOn average, countries scored/received 12.43 goals (SD = 10.53). Lets also look at the distributions:\n\n\nCode\nggplot(temp) + \n  geom_density(aes(x = scored, fill = \"Scored\"), alpha = 0.5) +\n  geom_density(aes(x = received, fill = \"Received\"), alpha = 0.5) +\n  scale_fill_manual(values = c(\"#74D055FF\",\"#39558CFF\")) + \n  labs(fill = \"Goals\",x = \"\", y=\"\", title = \"Distribution of Goals per Country\") +\n  theme(legend.position = c(0.8, 0.8)) +\n    scale_x_continuous(expand = c(0, 0), limits = c(0, 65)) + \n    scale_y_continuous(expand = c(0, 0), limits = c(0, 0.065))"
  },
  {
    "objectID": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#goals-scored-and-received-per-match",
    "href": "posts/2022-05-07_Predicting_ WM_ 22_ Part_ 1/index.html#goals-scored-and-received-per-match",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per match",
    "text": "Goals Scored and Received per match\nI am also interested in the single match-ups, for instance, how many goals are there in the average match, what are the most probably outcomes of a match, etc. Lets try to find this out. On average, there were 1.43 goals per game (SD = 1.72). The distribution of goals looks as follows:\n\n\nCode\ndata.frame(goals = c(quali22$goalsA,quali22$goalsB)) %>%\n  count(goals,sort=T) %>%\n  na.omit() %>% \n  ggplot(aes(x = goals,y = n)) + \n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), vjust = -0.3) +\n    ylim(0,560) +\n    labs(x = \"Nr. of Goals of one team\", y=\"Frequency\", title = \"Distribution of Goals per Match\") \n\n\n\n\n\nThe most common number of goals a team scores is 0 (sad). Now lets look at the results of the matches. I don’t really care if the match was 1:0 or 0:1, so I will treat both outcomes as the same. I will first recode the individual goals of team A and B into a match results variable result, which I can then use to count and plot the different results.\n\n\nCode\nquali22 %>%\n  na.omit() %>%\n  arrange(goalsA,goalsB) %>% \n  mutate(result = paste0(ifelse(goalsA > goalsB,goalsA,goalsB),\n                         \":\",\n                         ifelse(goalsA > goalsB,goalsB,goalsA))) %>%\n  count(result,sort=T) %>% \n  ggplot(aes(x = reorder(result,n),y = n)) +\n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), hjust = -0.12) +\n    coord_flip() +\n    scale_y_continuous(expand = c(0, 0), limits = c(0, 170)) +\n    labs(x = \"Match Result\", y = \"Frequency\")\n\n\n\n\n\nNot suprising, results of 1:0, 2:0, or 1:1 are the most common outcomes. Just out of curioisity, lets check the high scoring games:\n\n\nCode\nquali22 %>% filter(goalsA >= 10 | goalsB >= 10)\n\n\n# A tibble: 9 × 5\n  teamA          teamB                  goalsA goalsB region  \n  <chr>          <chr>                   <dbl>  <dbl> <chr>   \n1 Iran           Kambodscha                 14      0 Asia    \n2 Kambodscha     Iran                        0     10 Asia    \n3 Japan          Mongolei                   14      0 Asia    \n4 Japan          Myanmar                    10      0 Asia    \n5 Kaimaninseln   Kanada                      0     11 CONCACAF\n6 Guatemala      St. Vincent/Grenadines     10      0 CONCACAF\n7 Anguilla       Panama                      0     13 CONCACAF\n8 Turks & Caicos Haiti                       0     10 CONCACAF\n9 San Marino     England                     0     10 Europe  \n\n\nThose were some very one-sided match-ups."
  },
  {
    "objectID": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html",
    "href": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html",
    "title": "Predicting the WM22 Part 1",
    "section": "",
    "text": "With this series of blog posts, I wanted to learn more about Python, plotting maps with ggplot, modeling with STAN, football (?) and just practice writing. The aim is to predict the games of the 2022 football world championship using data from the qualifying games of all countries and informations about the individual players of each team. I scraped the data from open websites using Python. The scripts can be found on the corresponding Github page of this project. In this first blog post of the series, I want to explore the data set results_quali_matches.csv which contains the data of all qualifying games. I never used spatial data or plotted spatial data, so since I have data from all over the world, I want to try out plotting maps with ggplot. The main point of this blog post, however, is to get a feel for the data we have, which will be useful for our modeling attempts later."
  },
  {
    "objectID": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#making-world-maps-using-the-ggplot2",
    "href": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#making-world-maps-using-the-ggplot2",
    "title": "Predicting the WM22 Part 1",
    "section": "Making world maps using the ggplot2",
    "text": "Making world maps using the ggplot2\nNow I want to make a world map and then color each country by the number of goals scored/received. For this I will use the map package, which provides a data.frame that contains outlines of several continents.\n\n\nCode\nworld <- map_data(\"world\")\n\nhead(world)\n\n\n       long      lat group order region subregion\n1 -69.89912 12.45200     1     1  Aruba      <NA>\n2 -69.89571 12.42300     1     2  Aruba      <NA>\n3 -69.94219 12.43853     1     3  Aruba      <NA>\n4 -70.00415 12.50049     1     4  Aruba      <NA>\n5 -70.06612 12.54697     1     5  Aruba      <NA>\n6 -70.05088 12.59707     1     6  Aruba      <NA>\n\n\nThis world data.frame has the following variables: long for longitude, lat for latitude, group tells which adjacent points to connect, order refers to the sequence by which the points should be connected, and region and subregion annotate the area surrounded by a set of points. We can use this information to plot the world using ggplot:\n\n\nCode\nggplot(data = world, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\")  +\n  coord_fixed(1.3) + theme_map() # looks better\n\n\n\n\n\nBeautiful, isn’t it ? In order to color each country by the number of goals scored or received, we have to join the world and the country_stats data.frames together. However, before we can do this, we first have to make some processing steps in both data.frames. First, I need to translate the country names in the country_stats data.frames from German to English, since the region column in world contains the Names in English. Second, in the country_stats data.frame I have some “countries” which are rather sub-regions in world, for instance, Wales or Scotland. Thus, I need to create a new column in world which contains the same “countries” as in country_stats.\nTo translate the names, I use the countrycode package.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = countrycode(country, origin      = 'country.name.de',\n                                                             destination = 'country.name.en'))\ncountry_stats %>% head()\n\n\n# A tibble: 6 x 4\n  country    scored received country_en\n  <chr>       <dbl>    <dbl> <chr>     \n1 Japan          58        6 Japan     \n2 Kanada         50        8 Canada    \n3 Iran           49        8 Iran      \n4 Australien     43       11 Australia \n5 Brasilien      40        5 Brazil    \n6 China          39       22 China     \n\n\nThis worked quite well, except for the following warning: Some values were not matched unambiguously: Br. Jungferninseln, Djibouti, Dom. Republik, England, Kapverdische Inseln, Schottland, Sénégal, VA Emirate, Wales, Zentralafr. Republik. So I still have to put in some work by myself. I also added additional country name changes, based on checks a few code chunks further down.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = case_when(\n                      country == \"Djibouti\" ~ \"Djibouti\", # not sure why this didnt work before\n                      country == \"Br. Jungferninseln\" ~ \"Virgin Islands\",\n                      country == \"Dom. Republik\" ~ \"Dominican Republic\",\n                      country == \"England\" ~ \"Great Britain\",\n                      country == \"Kapverdische Inseln\" ~ \"Cape Verde\",\n                      country == \"Schottland\" ~ \"Scotland\",\n                      country == \"Sénégal\" ~ \"Senegal\",\n                      country == \"Wales\" ~ \"Wales\",\n                      country == \"Zentralafr. Republik\" ~ \"Central African Republic\",\n                      country == \"Bosnien-Herzegowina\" ~ \"Bosnia and Herzegovina\",\n                      country == \"Elfenbeinküste\" ~ \"Ivory Coast\",\n                      country == \"Tschechien\" ~ \"Czech Republic\",\n                      country == \"Curaçao\" ~ \"Curacao\",\n                      country == \"Kongo\" ~ \"Republic of Congo\",\n                      country == \"USA\" ~ \"USA\",\n                      country == \"DR Kongo\" ~ \"Democratic Republic of the Congo\",\n                      country == \"St. Kitts & Nevis\" ~ \"Nevis\",\n                      country == \"Antigua & Barbuda\" ~ \"Antigua\",\n                      country == \"Turks & Caicos\" ~ \"Turks and Caicos Islands\",\n                      country == \"Trinidad & Tobago\" ~ \"Trinidad\",\n                      country == \"St. Vincent/Grenadines\" ~ \"Saint Vincent\",\n                      country == \"VA Emirate\" ~ \"United Arab Emirates\",\n                      country == \"Hong Kong SAR China\" ~ \"Hongkong\",\n                      country == \"Palästina\" ~ \"Palestine\",\n                      country == \"Myanmar\" ~ \"Myanmar\",\n                      country == \"Nordirland\" ~ \"Northern Ireland\",\n                      TRUE ~ country_en\n                    )) \n \n\n\n# check if we have everything:\n# country_stats %>% filter(is.na(country_en))\ncountry_stats %>% head()\n\n\n# A tibble: 6 x 4\n  country    scored received country_en\n  <chr>       <dbl>    <dbl> <chr>     \n1 Japan          58        6 Japan     \n2 Kanada         50        8 Canada    \n3 Iran           49        8 Iran      \n4 Australien     43       11 Australia \n5 Brasilien      40        5 Brazil    \n6 China          39       22 China     \n\n\nNext I make a new variable in the worlds data.frame, which I will then use to join both data.frames together.\n\n\nCode\nworld <- world %>%\n            mutate(country_en = case_when(subregion == \"Wales\" ~ \"Wales\",\n                                          subregion == \"Northern Ireland\" ~ \"Northern Ireland\",\n                                          subregion == \"Scotland\" ~ \"Scotland\",\n                                          subregion == \"Great Britain\" ~ \"Great Britain\",\n                                          subregion == \"Grand Caicos Island\" ~ \"Turks and Caicos Islands\",\n                                          subregion == \"British\" ~ \"Virgin Islands\",\n                                          subregion == \"Hong Kong\" ~ \"Hong Kong\",\n                                          TRUE ~ region)) %>% \n            filter(region != \"USA\" | region == \"USA\" & (is.na(subregion) | subregion == \"Alaska\"),\n                   region != \"United Arab Emirates\" | region == \"United Arab Emirates\" & is.na(subregion),\n                   region != \"Myanmar\" | region == \"Myanmar\" & is.na(subregion),\n                   region != \"Ireland\" | region == \"Ireland\" & is.na(subregion))\n  \n# We need to add Gibraltar through a different dataset\n# \"worldHires\" is a more detailed version of \"world\"\ntemp <- map_data('worldHires')  %>% filter(subregion == \"Gibralter\") %>% mutate(country_en = \"Gibraltar\")\n  \n\nworld <- bind_rows(world,temp) %>% as_tibble() \n\n\nNow we can join both data.frames using left_join. Lets also clean the resulting data.frame a little bit.\n\n\nCode\ncountry_stats <- left_join(country_stats,world,by=\"country_en\") %>% \n                      select(region = country_en, scored, received, long, lat, group, order )\n\n# checks:\n# check if any countries do not have infos from world\n# country_stats %>% filter(is.na(long)) %>% pull(region) %>% unique()\n\n\nGreat, after some back and forth changes, I think I now have the position of every country in our data set. Lets check this, by just plotting all countries or regions where we have some data from.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\") +\n  coord_fixed(1.3) + theme_map()\n\n\n\n\n\nSo we this really is a “World” championship."
  },
  {
    "objectID": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#color-regions-by-goals-scored-and-recevied",
    "href": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#color-regions-by-goals-scored-and-recevied",
    "title": "Predicting the WM22 Part 1",
    "section": "Color regions by goals scored and recevied",
    "text": "Color regions by goals scored and recevied\nHere I color each country or region by the number of goals they scored and received in their qualifying matches. From the plots you can identify some countries which apparently did well in their group, since the score many goals, but received only few. For instance, Canada, Japan, German, or Brasil. There also seem to be fewer goals in African and south-east Asian countries.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Scored\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=received), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Received\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\n\nCode\n# p1 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Scored\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# p2 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=received), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Received\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# \n# p1 / p2\n# \n# \n# ggsave(\"goals_WM22_qualifying.svg\",width=30,height=30,unit=\"cm\")"
  },
  {
    "objectID": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-country",
    "href": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-country",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per Country",
    "text": "Goals Scored and Received per Country\n\n\nCode\ntemp <- country_stats %>% select(region,scored,received) %>% distinct()\n\n\nI also want to get a general idea of the distribution and relationship of the scored and received goals. There is only a small negative correlation between the number of goals scored and the number of goals received (r = -0.16), mostly driven by Japan.\n\n\nCode\np_scatter <- ggplot(temp,aes(x = scored, y = received)) +\n              geom_point(shape = 21, fill = \"lightgrey\",size = 2) +\n              geom_smooth(method = \"lm\") +\n              geom_label_repel(aes(label = region),\n                               box.padding   = 0.35, \n                               point.padding = 0.5,\n                               segment.color = 'grey50')\n\np_scatter\n\n\n\n\n\nOn average, countries scored/received 12.43 goals (SD = 10.53). Lets also look at the distributions:\n\n\nCode\nggplot(temp) + \n  geom_density(aes(x = scored, fill = \"Scored\"), alpha = 0.5) +\n  geom_density(aes(x = received, fill = \"Received\"), alpha = 0.5) +\n  scale_fill_manual(values = c(\"#74D055FF\",\"#39558CFF\")) + \n  labs(fill = \"Goals\",x = \"\", y=\"\", title = \"Distribution of Goals per Country\") +\n  theme(legend.position = c(0.8, 0.8)) +\n    scale_x_continuous(expand = c(0, 0), limits = c(0, 65)) + \n    scale_y_continuous(expand = c(0, 0), limits = c(0, 0.065))"
  },
  {
    "objectID": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-match",
    "href": "posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-match",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per match",
    "text": "Goals Scored and Received per match\nI am also interested in the single match-ups, for instance, how many goals are there in the average match, what are the most probably outcomes of a match, etc. Lets try to find this out. On average, there were 1.43 goals per game (SD = 1.72). The distribution of goals looks as follows:\n\n\nCode\ndata.frame(goals = c(quali22$goalsA,quali22$goalsB)) %>%\n  count(goals,sort=T) %>%\n  na.omit() %>% \n  ggplot(aes(x = goals,y = n)) + \n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), vjust = -0.3) +\n    ylim(0,560) +\n    labs(x = \"Nr. of Goals of one team\", y=\"Frequency\", title = \"Distribution of Goals per Match\") \n\n\n\n\n\nThe most common number of goals a team scores is 0 (sad). Now lets look at the results of the matches. I don’t really care if the match was 1:0 or 0:1, so I will treat both outcomes as the same. I will first recode the individual goals of team A and B into a match results variable result, which I can then use to count and plot the different results.\n\n\nCode\nquali22 %>%\n  na.omit() %>%\n  arrange(goalsA,goalsB) %>% \n  mutate(result = paste0(ifelse(goalsA > goalsB,goalsA,goalsB),\n                         \":\",\n                         ifelse(goalsA > goalsB,goalsB,goalsA))) %>%\n  count(result,sort=T) %>% \n  ggplot(aes(x = reorder(result,n),y = n)) +\n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), hjust = -0.12) +\n    coord_flip() +\n    scale_y_continuous(expand = c(0, 0), limits = c(0, 170)) +\n    labs(x = \"Match Result\", y = \"Frequency\")\n\n\n\n\n\nNot suprising, results of 1:0, 2:0, or 1:1 are the most common outcomes. Just out of curioisity, lets check the high scoring games:\n\n\nCode\nquali22 %>% filter(goalsA >= 10 | goalsB >= 10)\n\n\n# A tibble: 9 x 5\n  teamA          teamB                  goalsA goalsB region  \n  <chr>          <chr>                   <dbl>  <dbl> <chr>   \n1 Iran           Kambodscha                 14      0 Asia    \n2 Kambodscha     Iran                        0     10 Asia    \n3 Japan          Mongolei                   14      0 Asia    \n4 Japan          Myanmar                    10      0 Asia    \n5 Kaimaninseln   Kanada                      0     11 CONCACAF\n6 Guatemala      St. Vincent/Grenadines     10      0 CONCACAF\n7 Anguilla       Panama                      0     13 CONCACAF\n8 Turks & Caicos Haiti                       0     10 CONCACAF\n9 San Marino     England                     0     10 Europe  \n\n\nThose were some very one-sided match-ups."
  },
  {
    "objectID": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html",
    "href": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html",
    "title": "Predicting the WM22 Part 1",
    "section": "",
    "text": "The data\nI start by loading the packages I need, set a general theme for our plots, and then load our data.\n\n\nCode\nlibrary(tidyverse)\nlibrary(maps)\nlibrary(mapdata)\nlibrary(viridis)\nlibrary(patchwork)\nlibrary(countrycode)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(plotly)\nlibrary(kableExtra)\n\ntheme_set(\n  theme_bw() +\n    theme(plot.title = element_text(hjust = 0.5)) \n)\n\n\nquali22        <- read_csv2(\"../../../data/results_quali_matches.csv\")\nquali22$goalsA <- as.numeric(quali22$goalsA)\n\n\nOur data.frame generally looks like this:\n\n\nCode\nquali22\n\n\n\n  \n\n\n\nCode\ncountries <-  quali22$teamA %>% unique() \n\n\nIn total we have 796 matches from 183 in our data set. Lets start our exploration by calculating and then plotting the number of goals scored and received by each country. For this, I first want to create two new variables scored and received using a for-loop. There might be a “tidyverse” way to do this faster, however, I think the for-loop is pretty straight forward.\n\n\nCode\nn_countries <- length(countries)\nscored      <- vector(\"numeric\",n_countries)\nreceived    <- vector(\"numeric\",n_countries)\n\nfor(i in 1:length(countries)){\n\n  country <- countries[i]\n  rows    <- quali22 %>% filter(teamA == country | teamB == country) \n\n  temp    <- rows %>% mutate(scored  = case_when(\n                                        teamA == country ~ goalsA,\n                                        teamB == country ~ goalsB),\n                            received = case_when(\n                                        teamA == country ~ goalsB,\n                                        teamB == country ~ goalsA)) %>%\n                      summarize(scored   = sum(scored,na.rm=TRUE),\n                                received = sum(received,na.rm=TRUE))\n\n  scored[i]   <- temp$scored\n  received[i] <- temp$received\n}\n\n\nLets combine all variables to a new data.frame:\n\n\nCode\ncountry_stats <- tibble(\"country\" = countries,scored,received) %>%\n                    arrange(desc(scored)) \n\ncountry_stats\n\n\n\n  \n\n\n\n\n\nMaking world maps using the ggplot2\nNow I want to make a world map and then color each country by the number of goals scored/received. For this I will use the map package, which provides a data.frame that contains outlines of several continents.\n\n\nCode\nworld <- map_data(\"world\")\n\nworld\n\n\n\n  \n\n\n\nThis world data.frame has the following variables: long for longitude, lat for latitude, group tells which adjacent points to connect, order refers to the sequence by which the points should be connected, and region and subregion annotate the area surrounded by a set of points. We can use this information to plot the world using ggplot:\n\n\nCode\nggplot(data = world, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\")  +\n  coord_fixed(1.3) + theme_map() # looks better\n\n\n\n\n\nBeautiful, isn’t it ? In order to color each country by the number of goals scored or received, we have to join the world and the country_stats data.frames together. However, before we can do this, we first have to make some processing steps in both data.frames. First, I need to translate the country names in the country_stats data.frames from German to English, since the region column in world contains the Names in English. Second, in the country_stats data.frame I have some “countries” which are rather sub-regions in world, for instance, Wales or Scotland. Thus, I need to create a new column in world which contains the same “countries” as in country_stats.\nTo translate the names, I use the countrycode package.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = countrycode(country, origin      = 'country.name.de',\n                                                             destination = 'country.name.en'))\ncountry_stats\n\n\n\n  \n\n\n\nThis worked quite well, except for the following warning: Some values were not matched unambiguously: Br. Jungferninseln, Djibouti, Dom. Republik, England, Kapverdische Inseln, Schottland, Sénégal, VA Emirate, Wales, Zentralafr. Republik. So I still have to put in some work by myself. I also added additional country name changes, based on checks a few code chunks further down.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = case_when(\n                      country == \"Djibouti\" ~ \"Djibouti\", # not sure why this didnt work before\n                      country == \"Br. Jungferninseln\" ~ \"Virgin Islands\",\n                      country == \"Dom. Republik\" ~ \"Dominican Republic\",\n                      country == \"England\" ~ \"Great Britain\",\n                      country == \"Kapverdische Inseln\" ~ \"Cape Verde\",\n                      country == \"Schottland\" ~ \"Scotland\",\n                      country == \"Sénégal\" ~ \"Senegal\",\n                      country == \"Wales\" ~ \"Wales\",\n                      country == \"Zentralafr. Republik\" ~ \"Central African Republic\",\n                      country == \"Bosnien-Herzegowina\" ~ \"Bosnia and Herzegovina\",\n                      country == \"Elfenbeinküste\" ~ \"Ivory Coast\",\n                      country == \"Tschechien\" ~ \"Czech Republic\",\n                      country == \"Curaçao\" ~ \"Curacao\",\n                      country == \"Kongo\" ~ \"Republic of Congo\",\n                      country == \"USA\" ~ \"USA\",\n                      country == \"DR Kongo\" ~ \"Democratic Republic of the Congo\",\n                      country == \"St. Kitts & Nevis\" ~ \"Nevis\",\n                      country == \"Antigua & Barbuda\" ~ \"Antigua\",\n                      country == \"Turks & Caicos\" ~ \"Turks and Caicos Islands\",\n                      country == \"Trinidad & Tobago\" ~ \"Trinidad\",\n                      country == \"St. Vincent/Grenadines\" ~ \"Saint Vincent\",\n                      country == \"VA Emirate\" ~ \"United Arab Emirates\",\n                      country == \"Hong Kong SAR China\" ~ \"Hongkong\",\n                      country == \"Palästina\" ~ \"Palestine\",\n                      country == \"Myanmar\" ~ \"Myanmar\",\n                      country == \"Nordirland\" ~ \"Northern Ireland\",\n                      TRUE ~ country_en\n                    )) \n \n\n\n# check if we have everything:\n# country_stats %>% filter(is.na(country_en))\ncountry_stats\n\n\n\n  \n\n\n\nNext I make a new variable in the worlds data.frame, which I will then use to join both data.frames together.\n\n\nCode\nworld <- world %>%\n            mutate(country_en = case_when(subregion == \"Wales\" ~ \"Wales\",\n                                          subregion == \"Northern Ireland\" ~ \"Northern Ireland\",\n                                          subregion == \"Scotland\" ~ \"Scotland\",\n                                          subregion == \"Great Britain\" ~ \"Great Britain\",\n                                          subregion == \"Grand Caicos Island\" ~ \"Turks and Caicos Islands\",\n                                          subregion == \"British\" ~ \"Virgin Islands\",\n                                          subregion == \"Hong Kong\" ~ \"Hong Kong\",\n                                          TRUE ~ region)) %>% \n            filter(region != \"USA\" | region == \"USA\" & (is.na(subregion) | subregion == \"Alaska\"),\n                   region != \"United Arab Emirates\" | region == \"United Arab Emirates\" & is.na(subregion),\n                   region != \"Myanmar\" | region == \"Myanmar\" & is.na(subregion),\n                   region != \"Ireland\" | region == \"Ireland\" & is.na(subregion))\n  \n# We need to add Gibraltar through a different dataset\n# \"worldHires\" is a more detailed version of \"world\"\ntemp <- map_data('worldHires')  %>% filter(subregion == \"Gibralter\") %>% mutate(country_en = \"Gibraltar\")\n  \n\nworld <- bind_rows(world,temp) %>% as_tibble() \n\n\nNow we can join both data.frames using left_join. Lets also clean the resulting data.frame a little bit.\n\n\nCode\ncountry_stats <- left_join(country_stats,world,by=\"country_en\") %>% \n                      select(region = country_en, scored, received, long, lat, group, order )\n\n# checks:\n# check if any countries do not have infos from world\n# country_stats %>% filter(is.na(long)) %>% pull(region) %>% unique()\n\n\nGreat, after some back and forth changes, I think I now have the position of every country in our data set. Lets check this, by just plotting all countries or regions where we have some data from.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\") +\n  coord_fixed(1.3) + theme_map()\n\n\n\n\n\nSo we this really is a “World” championship.\n\n\nColor regions by goals scored and recevied\nHere I color each country or region by the number of goals they scored and received in their qualifying matches. From the plots you can identify some countries which apparently did well in their group, since the score many goals, but received only few. For instance, Canada, Japan, German, or Brasil. There also seem to be fewer goals in African and south-east Asian countries.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Scored\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=received), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Received\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\n\nGoals Scored and Received per Country\n\n\nCode\ntemp <- country_stats %>% select(region,scored,received) %>% distinct()\n\n\nI also want to get a general idea of the distribution and relationship of the scored and received goals. There is only a small negative correlation between the number of goals scored and the number of goals received (r = -0.16), mostly driven by Japan.\n\n\nCode\np_scatter <- ggplot(temp,aes(x = scored, y = received)) +\n              geom_point(shape = 21, fill = \"lightgrey\",size = 2) +\n              geom_smooth(method = \"lm\") +\n              geom_label_repel(aes(label = region),\n                               box.padding   = 0.35, \n                               point.padding = 0.5,\n                               segment.color = 'grey50')\n\np_scatter\n\n\n\n\n\nOn average, countries scored/received 12.43 goals (SD = 10.53). Lets also look at the distributions:\n\n\nCode\nggplot(temp) + \n  geom_density(aes(x = scored, fill = \"Scored\"), alpha = 0.5) +\n  geom_density(aes(x = received, fill = \"Received\"), alpha = 0.5) +\n  scale_fill_manual(values = c(\"#74D055FF\",\"#39558CFF\")) + \n  labs(fill = \"Goals\",x = \"\", y=\"\", title = \"Distribution of Goals per Country\") +\n  theme(legend.position = c(0.8, 0.8)) +\n    scale_x_continuous(expand = c(0, 0), limits = c(0, 65)) + \n    scale_y_continuous(expand = c(0, 0), limits = c(0, 0.065))\n\n\n\n\n\n\n\nGoals Scored and Received per Match\nI am also interested in the single match-ups, for instance, how many goals are there in the average match, what are the most probably outcomes of a match, etc. Lets try to find this out. On average, there were 1.43 goals per game (SD = 1.72). The distribution of goals looks as follows:\n\n\nCode\ndata.frame(goals = c(quali22$goalsA,quali22$goalsB)) %>%\n  count(goals,sort=T) %>%\n  na.omit() %>% \n  ggplot(aes(x = goals,y = n)) + \n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), vjust = -0.3) +\n    ylim(0,560) +\n    labs(x = \"Nr. of Goals of one team\", y=\"Frequency\", title = \"Distribution of Goals per Match\") \n\n\n\n\n\nThe most common number of goals a team scores is 0 (sad). Now lets look at the results of the matches. I don’t really care if the match was 1:0 or 0:1, so I will treat both outcomes as the same. I will first recode the individual goals of team A and B into a match results variable result, which I can then use to count and plot the different results.\n\n\nCode\nquali22 %>%\n  na.omit() %>%\n  arrange(goalsA,goalsB) %>% \n  mutate(result = paste0(ifelse(goalsA > goalsB,goalsA,goalsB),\n                         \":\",\n                         ifelse(goalsA > goalsB,goalsB,goalsA))) %>%\n  count(result,sort=T) %>% \n  ggplot(aes(x = reorder(result,n),y = n)) +\n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), hjust = -0.12) +\n    coord_flip() +\n    scale_y_continuous(expand = c(0, 0), limits = c(0, 170)) +\n    labs(x = \"Match Result\", y = \"Frequency\")\n\n\n\n\n\nNot suprising, results of 1:0, 2:0, or 1:1 are the most common outcomes. Just out of curioisity, lets check the high scoring games:\n\n\nCode\nquali22 %>% filter(goalsA >= 10 | goalsB >= 10)\n\n\n\n  \n\n\n\nThose were some very one-sided match-ups.\n\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/"
  },
  {
    "objectID": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#making-world-maps-using-the-ggplot2",
    "href": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#making-world-maps-using-the-ggplot2",
    "title": "Predicting the WM22 Part 1",
    "section": "Making world maps using the ggplot2",
    "text": "Making world maps using the ggplot2\nNow I want to make a world map and then color each country by the number of goals scored/received. For this I will use the map package, which provides a data.frame that contains outlines of several continents.\n\n\nCode\nworld <- map_data(\"world\")\n\nhead(world)\n\n\n\n  \n\n\n\nThis world data.frame has the following variables: long for longitude, lat for latitude, group tells which adjacent points to connect, order refers to the sequence by which the points should be connected, and region and subregion annotate the area surrounded by a set of points. We can use this information to plot the world using ggplot:\n\n\nCode\nggplot(data = world, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\")  +\n  coord_fixed(1.3) + theme_map() # looks better\n\n\n\n\n\nBeautiful, isn’t it ? In order to color each country by the number of goals scored or received, we have to join the world and the country_stats data.frames together. However, before we can do this, we first have to make some processing steps in both data.frames. First, I need to translate the country names in the country_stats data.frames from German to English, since the region column in world contains the Names in English. Second, in the country_stats data.frame I have some “countries” which are rather sub-regions in world, for instance, Wales or Scotland. Thus, I need to create a new column in world which contains the same “countries” as in country_stats.\nTo translate the names, I use the countrycode package.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = countrycode(country, origin      = 'country.name.de',\n                                                             destination = 'country.name.en'))\ncountry_stats %>% head()\n\n\n\n  \n\n\n\nThis worked quite well, except for the following warning: Some values were not matched unambiguously: Br. Jungferninseln, Djibouti, Dom. Republik, England, Kapverdische Inseln, Schottland, Sénégal, VA Emirate, Wales, Zentralafr. Republik. So I still have to put in some work by myself. I also added additional country name changes, based on checks a few code chunks further down.\n\n\nCode\ncountry_stats <- country_stats %>%\n                    mutate(country_en = case_when(\n                      country == \"Djibouti\" ~ \"Djibouti\", # not sure why this didnt work before\n                      country == \"Br. Jungferninseln\" ~ \"Virgin Islands\",\n                      country == \"Dom. Republik\" ~ \"Dominican Republic\",\n                      country == \"England\" ~ \"Great Britain\",\n                      country == \"Kapverdische Inseln\" ~ \"Cape Verde\",\n                      country == \"Schottland\" ~ \"Scotland\",\n                      country == \"Sénégal\" ~ \"Senegal\",\n                      country == \"Wales\" ~ \"Wales\",\n                      country == \"Zentralafr. Republik\" ~ \"Central African Republic\",\n                      country == \"Bosnien-Herzegowina\" ~ \"Bosnia and Herzegovina\",\n                      country == \"Elfenbeinküste\" ~ \"Ivory Coast\",\n                      country == \"Tschechien\" ~ \"Czech Republic\",\n                      country == \"Curaçao\" ~ \"Curacao\",\n                      country == \"Kongo\" ~ \"Republic of Congo\",\n                      country == \"USA\" ~ \"USA\",\n                      country == \"DR Kongo\" ~ \"Democratic Republic of the Congo\",\n                      country == \"St. Kitts & Nevis\" ~ \"Nevis\",\n                      country == \"Antigua & Barbuda\" ~ \"Antigua\",\n                      country == \"Turks & Caicos\" ~ \"Turks and Caicos Islands\",\n                      country == \"Trinidad & Tobago\" ~ \"Trinidad\",\n                      country == \"St. Vincent/Grenadines\" ~ \"Saint Vincent\",\n                      country == \"VA Emirate\" ~ \"United Arab Emirates\",\n                      country == \"Hong Kong SAR China\" ~ \"Hongkong\",\n                      country == \"Palästina\" ~ \"Palestine\",\n                      country == \"Myanmar\" ~ \"Myanmar\",\n                      country == \"Nordirland\" ~ \"Northern Ireland\",\n                      TRUE ~ country_en\n                    )) \n \n\n\n# check if we have everything:\n# country_stats %>% filter(is.na(country_en))\ncountry_stats %>% head()\n\n\n\n  \n\n\n\nNext I make a new variable in the worlds data.frame, which I will then use to join both data.frames together.\n\n\nCode\nworld <- world %>%\n            mutate(country_en = case_when(subregion == \"Wales\" ~ \"Wales\",\n                                          subregion == \"Northern Ireland\" ~ \"Northern Ireland\",\n                                          subregion == \"Scotland\" ~ \"Scotland\",\n                                          subregion == \"Great Britain\" ~ \"Great Britain\",\n                                          subregion == \"Grand Caicos Island\" ~ \"Turks and Caicos Islands\",\n                                          subregion == \"British\" ~ \"Virgin Islands\",\n                                          subregion == \"Hong Kong\" ~ \"Hong Kong\",\n                                          TRUE ~ region)) %>% \n            filter(region != \"USA\" | region == \"USA\" & (is.na(subregion) | subregion == \"Alaska\"),\n                   region != \"United Arab Emirates\" | region == \"United Arab Emirates\" & is.na(subregion),\n                   region != \"Myanmar\" | region == \"Myanmar\" & is.na(subregion),\n                   region != \"Ireland\" | region == \"Ireland\" & is.na(subregion))\n  \n# We need to add Gibraltar through a different dataset\n# \"worldHires\" is a more detailed version of \"world\"\ntemp <- map_data('worldHires')  %>% filter(subregion == \"Gibralter\") %>% mutate(country_en = \"Gibraltar\")\n  \n\nworld <- bind_rows(world,temp) %>% as_tibble() \n\n\nNow we can join both data.frames using left_join. Lets also clean the resulting data.frame a little bit.\n\n\nCode\ncountry_stats <- left_join(country_stats,world,by=\"country_en\") %>% \n                      select(region = country_en, scored, received, long, lat, group, order )\n\n# checks:\n# check if any countries do not have infos from world\n# country_stats %>% filter(is.na(long)) %>% pull(region) %>% unique()\n\n\nGreat, after some back and forth changes, I think I now have the position of every country in our data set. Lets check this, by just plotting all countries or regions where we have some data from.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(color=\"black\",fill=\"lightgrey\") +\n  coord_fixed(1.3) + theme_map()\n\n\n\n\n\nSo we this really is a “World” championship."
  },
  {
    "objectID": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#color-regions-by-goals-scored-and-recevied",
    "href": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#color-regions-by-goals-scored-and-recevied",
    "title": "Predicting the WM22 Part 1",
    "section": "Color regions by goals scored and recevied",
    "text": "Color regions by goals scored and recevied\nHere I color each country or region by the number of goals they scored and received in their qualifying matches. From the plots you can identify some countries which apparently did well in their group, since the score many goals, but received only few. For instance, Canada, Japan, German, or Brasil. There also seem to be fewer goals in African and south-east Asian countries.\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Scored\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\nCode\nggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n  geom_polygon(aes(fill=received), color=\"black\",size = 0.5) + \n  scale_fill_viridis() +\n  coord_fixed(1.3) +\n  labs(title = \"Goals Received\") + theme_map() +\n  theme(plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\n\nCode\n# p1 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=scored), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Scored\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# p2 <- ggplot(data = country_stats, aes(x=long, y = lat, group = group)) +\n#   geom_polygon(aes(fill=received), color=\"black\",size = 0.5) +\n#   scale_fill_viridis() +\n#   labs(title = \"Goals Received\") + theme_map() +\n#   theme(plot.title = element_text(hjust = 0.5))\n# \n# \n# p1 / p2\n# \n# \n# ggsave(\"goals_WM22_qualifying.svg\",width=30,height=30,unit=\"cm\")"
  },
  {
    "objectID": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-country",
    "href": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-country",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per Country",
    "text": "Goals Scored and Received per Country\n\n\nCode\ntemp <- country_stats %>% select(region,scored,received) %>% distinct()\n\n\nI also want to get a general idea of the distribution and relationship of the scored and received goals. There is only a small negative correlation between the number of goals scored and the number of goals received (r = -0.16), mostly driven by Japan.\n\n\nCode\np_scatter <- ggplot(temp,aes(x = scored, y = received)) +\n              geom_point(shape = 21, fill = \"lightgrey\",size = 2) +\n              geom_smooth(method = \"lm\") +\n              geom_label_repel(aes(label = region),\n                               box.padding   = 0.35, \n                               point.padding = 0.5,\n                               segment.color = 'grey50')\n\np_scatter\n\n\n\n\n\nOn average, countries scored/received 12.43 goals (SD = 10.53). Lets also look at the distributions:\n\n\nCode\nggplot(temp) + \n  geom_density(aes(x = scored, fill = \"Scored\"), alpha = 0.5) +\n  geom_density(aes(x = received, fill = \"Received\"), alpha = 0.5) +\n  scale_fill_manual(values = c(\"#74D055FF\",\"#39558CFF\")) + \n  labs(fill = \"Goals\",x = \"\", y=\"\", title = \"Distribution of Goals per Country\") +\n  theme(legend.position = c(0.8, 0.8)) +\n    scale_x_continuous(expand = c(0, 0), limits = c(0, 65)) + \n    scale_y_continuous(expand = c(0, 0), limits = c(0, 0.065))"
  },
  {
    "objectID": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-match",
    "href": "blog/posts/2022-05-07-Predicting-WM-22-Part-1/index.html#goals-scored-and-received-per-match",
    "title": "Predicting the WM22 Part 1",
    "section": "Goals Scored and Received per match",
    "text": "Goals Scored and Received per match\nI am also interested in the single match-ups, for instance, how many goals are there in the average match, what are the most probably outcomes of a match, etc. Lets try to find this out. On average, there were 1.43 goals per game (SD = 1.72). The distribution of goals looks as follows:\n\n\nCode\ndata.frame(goals = c(quali22$goalsA,quali22$goalsB)) %>%\n  count(goals,sort=T) %>%\n  na.omit() %>% \n  ggplot(aes(x = goals,y = n)) + \n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), vjust = -0.3) +\n    ylim(0,560) +\n    labs(x = \"Nr. of Goals of one team\", y=\"Frequency\", title = \"Distribution of Goals per Match\") \n\n\n\n\n\nThe most common number of goals a team scores is 0 (sad). Now lets look at the results of the matches. I don’t really care if the match was 1:0 or 0:1, so I will treat both outcomes as the same. I will first recode the individual goals of team A and B into a match results variable result, which I can then use to count and plot the different results.\n\n\nCode\nquali22 %>%\n  na.omit() %>%\n  arrange(goalsA,goalsB) %>% \n  mutate(result = paste0(ifelse(goalsA > goalsB,goalsA,goalsB),\n                         \":\",\n                         ifelse(goalsA > goalsB,goalsB,goalsA))) %>%\n  count(result,sort=T) %>% \n  ggplot(aes(x = reorder(result,n),y = n)) +\n    geom_col(fill=\"#39558CFF\") +\n    geom_text(aes(label = n), hjust = -0.12) +\n    coord_flip() +\n    scale_y_continuous(expand = c(0, 0), limits = c(0, 170)) +\n    labs(x = \"Match Result\", y = \"Frequency\")\n\n\n\n\n\nNot suprising, results of 1:0, 2:0, or 1:1 are the most common outcomes. Just out of curioisity, lets check the high scoring games:\n\n\nCode\nquali22 %>% filter(goalsA >= 10 | goalsB >= 10)\n\n\n# A tibble: 9 x 5\n  teamA          teamB                  goalsA goalsB region  \n  <chr>          <chr>                   <dbl>  <dbl> <chr>   \n1 Iran           Kambodscha                 14      0 Asia    \n2 Kambodscha     Iran                        0     10 Asia    \n3 Japan          Mongolei                   14      0 Asia    \n4 Japan          Myanmar                    10      0 Asia    \n5 Kaimaninseln   Kanada                      0     11 CONCACAF\n6 Guatemala      St. Vincent/Grenadines     10      0 CONCACAF\n7 Anguilla       Panama                      0     13 CONCACAF\n8 Turks & Caicos Haiti                       0     10 CONCACAF\n9 San Marino     England                     0     10 Europe  \n\n\nThose were some very one-sided match-ups."
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Explore the results of all qualifying matches for the WM 2022 football championship\n\n\n\n\nfootball\n\n\nSTAN\n\n\n\n\nThis post explores the the results of all qualifying matches for the WM 2022 football championship. In subsequent blog posts, this information will be used to model the data and predicting future matches.\n\n\n\n\n\n\nMay 7, 2022\n\n\nCharles Teague\n\n\n\n\n\n\nNo matching items"
  }
]